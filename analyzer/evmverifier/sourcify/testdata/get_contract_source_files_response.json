{
  "status": "full",
  "files": [
    {
      "name": "metadata.json",
      "path": "/data/repository/contracts/full_match/23294/0x127c49aE10e3c18be057106F4d16946E3Ae43975/metadata.json",
      "content": "{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"InvalidQuote\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MismatchedRegistration\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RegistrationExpired\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"TcbId\",\"name\":\"tcbId\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"measurementHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"userdata\",\"type\":\"bytes32\"}],\"indexed\":false,\"internalType\":\"struct AttestationToken.Quote\",\"name\":\"quote\",\"type\":\"tuple\"}],\"name\":\"Attested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_quote\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"baseBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"baseBlockHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"registrant\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenExpiry\",\"type\":\"uint256\"}],\"internalType\":\"struct AttestationToken.Registration\",\"name\":\"_reg\",\"type\":\"tuple\"}],\"name\":\"attest\",\"outputs\":[{\"internalType\":\"TcbId\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"TcbId\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"attestations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_quote\",\"type\":\"bytes\"}],\"name\":\"getTcbId\",\"outputs\":[{\"internalType\":\"TcbId\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_whom\",\"type\":\"address\"},{\"internalType\":\"TcbId\",\"name\":\"_tcbId\",\"type\":\"bytes32\"}],\"name\":\"isAttested\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_whom\",\"type\":\"address\"}],\"name\":\"setTrustedSender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"errors\":{\"MismatchedRegistration()\":[{\"notice\":\"The quote did not link to the registration bundle.\"}],\"RegistrationExpired()\":[{\"notice\":\"The registration has expired.\"}]},\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/enclave-identity/AttestationToken.sol\":\"AttestationToken\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xa94b34880e3c1b0b931662cb1c09e5dfa6662f31cba80e07c5ee71cd135c9673\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"contracts/enclave-identity/AttestationToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n// import \\\"hardhat/console.sol\\\";\\n\\ntype TcbId is bytes32;\\n\\n/// The quote did not link to the registration bundle.\\nerror MismatchedRegistration(); // kPomqw==\\n/// The registration has expired.\\nerror RegistrationExpired(); // D+WbwA==\\nerror InvalidQuote(); // +GGAMA==\\n\\ncontract AttestationToken is Ownable {\\n    struct Quote {\\n        bytes32 measurementHash;\\n        bytes32 userdata;\\n    }\\n\\n    struct Registration {\\n        uint256 baseBlockNumber;\\n        bytes32 baseBlockHash;\\n        uint256 expiry;\\n        address registrant;\\n        uint256 tokenExpiry;\\n    }\\n\\n    struct Attestation {\\n        uint256 expiry;\\n    }\\n\\n    event Attested(address indexed requester, TcbId indexed tcbId, Quote quote);\\n\\n    mapping(address => mapping(TcbId => Attestation)) public attestations;\\n\\n    /// Mock attestation component.\\n    address private trustedSender;\\n\\n    function attest(bytes calldata _quote, Registration calldata _reg) external returns (TcbId) {\\n        Quote memory quote = _parseQuote(_quote);\\n        _validateRegistration(quote.userdata, _reg);\\n        TcbId tcbId = _getTcbId(quote);\\n        attestations[_reg.registrant][tcbId] = Attestation({expiry: _reg.tokenExpiry});\\n        emit Attested(_reg.registrant, tcbId, quote);\\n        return tcbId;\\n    }\\n\\n    function getTcbId(bytes calldata _quote) external view returns (TcbId) {\\n        Quote memory quote = _parseQuote(_quote);\\n        return _getTcbId(quote);\\n    }\\n\\n    function isAttested(address _whom, TcbId _tcbId) external view returns (bool) {\\n        return attestations[_whom][_tcbId].expiry > block.timestamp;\\n    }\\n\\n    function setTrustedSender(address _whom) external onlyOwner {\\n        trustedSender = _whom;\\n    }\\n\\n    function _getTcbId(Quote memory quote) internal view returns (TcbId) {\\n        return TcbId.wrap(keccak256(abi.encode(quote.measurementHash, \\\"mock tcb\\\", block.chainid)));\\n    }\\n\\n    function _parseQuote(bytes calldata _quote) internal view returns (Quote memory quote) {\\n        quote = abi.decode(_quote, (Quote));\\n        if (msg.sender != trustedSender) revert InvalidQuote(); // mock verification\\n    }\\n\\n    function _validateRegistration(\\n        bytes32 _expectedHash,\\n        Registration calldata _reg\\n    ) internal view {\\n        if (keccak256(abi.encode(_reg)) != _expectedHash) revert MismatchedRegistration();\\n        if (\\n            blockhash(_reg.baseBlockNumber) != _reg.baseBlockHash ||\\n            block.timestamp >= _reg.expiry\\n        ) revert RegistrationExpired();\\n    }\\n}\\n\",\"keccak256\":\"0x186e2fcaa7b12d7d2542d29b62b0012c67e9017a2ebe3b6a7837ef1e4b23975d\",\"license\":\"MIT\"}},\"version\":1}"
    },
    {
      "name": "Ownable.sol",
      "path": "/data/repository/contracts/full_match/23294/0x127c49aE10e3c18be057106F4d16946E3Ae43975/sources/_openzeppelin/contracts/access/Ownable.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    {
      "name": "Context.sol",
      "path": "/data/repository/contracts/full_match/23294/0x127c49aE10e3c18be057106F4d16946E3Ae43975/sources/_openzeppelin/contracts/utils/Context.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    {
      "name": "AttestationToken.sol",
      "path": "/data/repository/contracts/full_match/23294/0x127c49aE10e3c18be057106F4d16946E3Ae43975/sources/contracts/enclave-identity/AttestationToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n// import \"hardhat/console.sol\";\n\ntype TcbId is bytes32;\n\n/// The quote did not link to the registration bundle.\nerror MismatchedRegistration(); // kPomqw==\n/// The registration has expired.\nerror RegistrationExpired(); // D+WbwA==\nerror InvalidQuote(); // +GGAMA==\n\ncontract AttestationToken is Ownable {\n    struct Quote {\n        bytes32 measurementHash;\n        bytes32 userdata;\n    }\n\n    struct Registration {\n        uint256 baseBlockNumber;\n        bytes32 baseBlockHash;\n        uint256 expiry;\n        address registrant;\n        uint256 tokenExpiry;\n    }\n\n    struct Attestation {\n        uint256 expiry;\n    }\n\n    event Attested(address indexed requester, TcbId indexed tcbId, Quote quote);\n\n    mapping(address => mapping(TcbId => Attestation)) public attestations;\n\n    /// Mock attestation component.\n    address private trustedSender;\n\n    function attest(bytes calldata _quote, Registration calldata _reg) external returns (TcbId) {\n        Quote memory quote = _parseQuote(_quote);\n        _validateRegistration(quote.userdata, _reg);\n        TcbId tcbId = _getTcbId(quote);\n        attestations[_reg.registrant][tcbId] = Attestation({expiry: _reg.tokenExpiry});\n        emit Attested(_reg.registrant, tcbId, quote);\n        return tcbId;\n    }\n\n    function getTcbId(bytes calldata _quote) external view returns (TcbId) {\n        Quote memory quote = _parseQuote(_quote);\n        return _getTcbId(quote);\n    }\n\n    function isAttested(address _whom, TcbId _tcbId) external view returns (bool) {\n        return attestations[_whom][_tcbId].expiry > block.timestamp;\n    }\n\n    function setTrustedSender(address _whom) external onlyOwner {\n        trustedSender = _whom;\n    }\n\n    function _getTcbId(Quote memory quote) internal view returns (TcbId) {\n        return TcbId.wrap(keccak256(abi.encode(quote.measurementHash, \"mock tcb\", block.chainid)));\n    }\n\n    function _parseQuote(bytes calldata _quote) internal view returns (Quote memory quote) {\n        quote = abi.decode(_quote, (Quote));\n        if (msg.sender != trustedSender) revert InvalidQuote(); // mock verification\n    }\n\n    function _validateRegistration(\n        bytes32 _expectedHash,\n        Registration calldata _reg\n    ) internal view {\n        if (keccak256(abi.encode(_reg)) != _expectedHash) revert MismatchedRegistration();\n        if (\n            blockhash(_reg.baseBlockNumber) != _reg.baseBlockHash ||\n            block.timestamp >= _reg.expiry\n        ) revert RegistrationExpired();\n    }\n}\n"
    }
  ]
}
