package types

import (
	"fmt"

	ethCommon "github.com/ethereum/go-ethereum/common"
	"github.com/oasisprotocol/oasis-core/go/common/crypto/address"
	sdkTypes "github.com/oasisprotocol/oasis-sdk/client-sdk/go/types"

	common "github.com/oasisprotocol/nexus/common"
)

// Hardcoded event names emitted by ERC-20 contracts.
// TODO: Query the ABI of the contract for the event names, remove these.
const (
	Erc20Transfer = "Transfer"
	Erc20Approval = "Approval"
)

func (c ConsensusEventType) IsValid() bool {
	switch c {
	case ConsensusEventTypeStakingTransfer,
		ConsensusEventTypeStakingBurn,
		ConsensusEventTypeStakingEscrowAdd,
		ConsensusEventTypeStakingEscrowTake,
		ConsensusEventTypeStakingEscrowDebondingStart,
		ConsensusEventTypeStakingEscrowReclaim,
		ConsensusEventTypeStakingAllowanceChange,
		ConsensusEventTypeRegistryRuntime,
		ConsensusEventTypeRegistryEntity,
		ConsensusEventTypeRegistryNode,
		ConsensusEventTypeRegistryNodeUnfrozen,
		ConsensusEventTypeRoothashExecutorCommitted,
		ConsensusEventTypeRoothashExecutionDiscrepancy,
		ConsensusEventTypeRoothashFinalized,
		ConsensusEventTypeGovernanceProposalSubmitted,
		ConsensusEventTypeGovernanceProposalExecuted,
		ConsensusEventTypeGovernanceProposalFinalized,
		ConsensusEventTypeGovernanceVote:
		return true
	default:
		return false
	}
}

func (c Layer) IsValid() bool {
	switch c {
	case LayerConsensus, LayerCipher, LayerEmerald, LayerSapphire, LayerPontusxtest, LayerPontusxdev:
		return true
	default:
		return false
	}
}

func (c Runtime) IsValid() bool {
	switch c {
	case RuntimeCipher, RuntimeEmerald, RuntimeSapphire, RuntimePontusxtest, RuntimePontusxdev:
		return true
	default:
		return false
	}
}

func (c Runtime) Validate() (common.Runtime, error) {
	if !c.IsValid() {
		return "", &InvalidParamFormatError{ParamName: "runtime", Err: fmt.Errorf("not a valid runtime value: %s", c)}
	}
	switch c {
	case RuntimeCipher:
		return common.RuntimeCipher, nil
	case RuntimeEmerald:
		return common.RuntimeEmerald, nil
	case RuntimeSapphire:
		return common.RuntimeSapphire, nil
	case RuntimePontusxtest:
		return common.RuntimePontusxTest, nil
	case RuntimePontusxdev:
		return common.RuntimePontusxDev, nil
	default:
		return "", &InvalidParamFormatError{ParamName: "runtime", Err: fmt.Errorf("not a valid runtime value: %s", c)}
	}
}

// Validate validates the parameters.
func (p *GetLayerStatsActiveAccountsParams) Validate() error {
	if p.WindowStepSeconds == nil {
		return nil
	}
	if *p.WindowStepSeconds == 300 || *p.WindowStepSeconds == 86400 {
		return nil
	}
	return &InvalidParamFormatError{ParamName: "window_step_seconds", Err: fmt.Errorf("invalid value: %d", *p.WindowStepSeconds)}
}

// Converts the input text into a valid oasis-core Address. The input
// string is expected to be either an ethereum address or an oasis
// bech32-encoded address.
//
// Note: Though the regex pattern in the openapi EthOrOasisAddress type
// spec specifies that
// the input string conforms to either an oasis bech32-encoded address or
// an ethereum address, the autogenerated code does not actually verify
// this, so we validate the input string here.
func UnmarshalToOcAddress(text *string) (*StakingAddress, error) {
	if text == nil {
		return nil, nil
	}
	if ethCommon.IsHexAddress(*text) {
		ea := ethCommon.HexToAddress(*text)
		ctx := sdkTypes.AddressV0Secp256k1EthContext
		oasisAddr := StakingAddress(address.NewAddress(ctx, ea[:]))
		return &oasisAddr, nil
	}
	var a StakingAddress
	if err := a.UnmarshalText([]byte(*text)); err != nil {
		return nil, fmt.Errorf("malformed input address")
	}
	return &a, nil
}
