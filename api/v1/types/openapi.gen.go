// Package types provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package types

import (
	"time"

	common "github.com/oasisprotocol/nexus/common"
	staking "github.com/oasisprotocol/nexus/coreapi/v22.2.11/staking/api"
	signature "github.com/oasisprotocol/oasis-core/go/common/crypto/signature"
)

// Defines values for AddressDerivationContext.
const (
	AddressDerivationContextOasisCoreaddressStaking            AddressDerivationContext = "oasis-core/address: staking"
	AddressDerivationContextOasisRuntimeSdkaddressModule       AddressDerivationContext = "oasis-runtime-sdk/address: module"
	AddressDerivationContextOasisRuntimeSdkaddressMultisig     AddressDerivationContext = "oasis-runtime-sdk/address: multisig"
	AddressDerivationContextOasisRuntimeSdkaddressRuntime      AddressDerivationContext = "oasis-runtime-sdk/address: runtime"
	AddressDerivationContextOasisRuntimeSdkaddressSecp256k1eth AddressDerivationContext = "oasis-runtime-sdk/address: secp256k1eth"
	AddressDerivationContextOasisRuntimeSdkaddressSr25519      AddressDerivationContext = "oasis-runtime-sdk/address: sr25519"
)

// Defines values for ConsensusEventType.
const (
	ConsensusEventTypeGovernanceProposalExecuted   ConsensusEventType = "governance.proposal_executed"
	ConsensusEventTypeGovernanceProposalFinalized  ConsensusEventType = "governance.proposal_finalized"
	ConsensusEventTypeGovernanceProposalSubmitted  ConsensusEventType = "governance.proposal_submitted"
	ConsensusEventTypeGovernanceVote               ConsensusEventType = "governance.vote"
	ConsensusEventTypeRegistryEntity               ConsensusEventType = "registry.entity"
	ConsensusEventTypeRegistryNode                 ConsensusEventType = "registry.node"
	ConsensusEventTypeRegistryNodeUnfrozen         ConsensusEventType = "registry.node_unfrozen"
	ConsensusEventTypeRegistryRuntime              ConsensusEventType = "registry.runtime"
	ConsensusEventTypeRegistryRuntimeSuspended     ConsensusEventType = "registry.runtime_suspended"
	ConsensusEventTypeRoothashExecutionDiscrepancy ConsensusEventType = "roothash.execution_discrepancy"
	ConsensusEventTypeRoothashExecutorCommitted    ConsensusEventType = "roothash.executor_committed"
	ConsensusEventTypeRoothashFinalized            ConsensusEventType = "roothash.finalized"
	ConsensusEventTypeRoothashInMsgProcessed       ConsensusEventType = "roothash.in_msg_processed"
	ConsensusEventTypeRoothashMessage              ConsensusEventType = "roothash.message"
	ConsensusEventTypeStakingAllowanceChange       ConsensusEventType = "staking.allowance_change"
	ConsensusEventTypeStakingBurn                  ConsensusEventType = "staking.burn"
	ConsensusEventTypeStakingEscrowAdd             ConsensusEventType = "staking.escrow.add"
	ConsensusEventTypeStakingEscrowDebondingStart  ConsensusEventType = "staking.escrow.debonding_start"
	ConsensusEventTypeStakingEscrowReclaim         ConsensusEventType = "staking.escrow.reclaim"
	ConsensusEventTypeStakingEscrowTake            ConsensusEventType = "staking.escrow.take"
	ConsensusEventTypeStakingTransfer              ConsensusEventType = "staking.transfer"
)

// Defines values for ConsensusTxMethod.
const (
	ConsensusTxMethodBeaconPVSSCommit                 ConsensusTxMethod = "beacon.PVSSCommit"
	ConsensusTxMethodBeaconPVSSReveal                 ConsensusTxMethod = "beacon.PVSSReveal"
	ConsensusTxMethodBeaconVRFProve                   ConsensusTxMethod = "beacon.VRFProve"
	ConsensusTxMethodConsensusMeta                    ConsensusTxMethod = "consensus.Meta"
	ConsensusTxMethodGovernanceCastVote               ConsensusTxMethod = "governance.CastVote"
	ConsensusTxMethodGovernanceSubmitProposal         ConsensusTxMethod = "governance.SubmitProposal"
	ConsensusTxMethodKeymanagerPublishEphemeralSecret ConsensusTxMethod = "keymanager.PublishEphemeralSecret"
	ConsensusTxMethodKeymanagerPublishMasterSecret    ConsensusTxMethod = "keymanager.PublishMasterSecret"
	ConsensusTxMethodKeymanagerUpdatePolicy           ConsensusTxMethod = "keymanager.UpdatePolicy"
	ConsensusTxMethodKeymanagerchurpApply             ConsensusTxMethod = "keymanager/churp.Apply"
	ConsensusTxMethodKeymanagerchurpConfirm           ConsensusTxMethod = "keymanager/churp.Confirm"
	ConsensusTxMethodKeymanagerchurpCreate            ConsensusTxMethod = "keymanager/churp.Create"
	ConsensusTxMethodKeymanagerchurpUpdate            ConsensusTxMethod = "keymanager/churp.Update"
	ConsensusTxMethodRegistryDeregisterEntity         ConsensusTxMethod = "registry.DeregisterEntity"
	ConsensusTxMethodRegistryProveFreshness           ConsensusTxMethod = "registry.ProveFreshness"
	ConsensusTxMethodRegistryRegisterEntity           ConsensusTxMethod = "registry.RegisterEntity"
	ConsensusTxMethodRegistryRegisterNode             ConsensusTxMethod = "registry.RegisterNode"
	ConsensusTxMethodRegistryRegisterRuntime          ConsensusTxMethod = "registry.RegisterRuntime"
	ConsensusTxMethodRegistryUnfreezeNode             ConsensusTxMethod = "registry.UnfreezeNode"
	ConsensusTxMethodRoothashEvidence                 ConsensusTxMethod = "roothash.Evidence"
	ConsensusTxMethodRoothashExecutorCommit           ConsensusTxMethod = "roothash.ExecutorCommit"
	ConsensusTxMethodRoothashExecutorProposerTimeout  ConsensusTxMethod = "roothash.ExecutorProposerTimeout"
	ConsensusTxMethodRoothashSubmitMsg                ConsensusTxMethod = "roothash.SubmitMsg"
	ConsensusTxMethodStakingAddEscrow                 ConsensusTxMethod = "staking.AddEscrow"
	ConsensusTxMethodStakingAllow                     ConsensusTxMethod = "staking.Allow"
	ConsensusTxMethodStakingAmendCommissionSchedule   ConsensusTxMethod = "staking.AmendCommissionSchedule"
	ConsensusTxMethodStakingBurn                      ConsensusTxMethod = "staking.Burn"
	ConsensusTxMethodStakingReclaimEscrow             ConsensusTxMethod = "staking.ReclaimEscrow"
	ConsensusTxMethodStakingTransfer                  ConsensusTxMethod = "staking.Transfer"
	ConsensusTxMethodStakingWithdraw                  ConsensusTxMethod = "staking.Withdraw"
	ConsensusTxMethodVaultAuthorizeAction             ConsensusTxMethod = "vault.AuthorizeAction"
	ConsensusTxMethodVaultCancelAction                ConsensusTxMethod = "vault.CancelAction"
	ConsensusTxMethodVaultCreate                      ConsensusTxMethod = "vault.Create"
)

// Defines values for EvmTokenType.
const (
	EvmTokenTypeERC20  EvmTokenType = "ERC20"
	EvmTokenTypeERC721 EvmTokenType = "ERC721"
)

// Defines values for Layer.
const (
	LayerCipher      Layer = "cipher"
	LayerConsensus   Layer = "consensus"
	LayerEmerald     Layer = "emerald"
	LayerPontusxdev  Layer = "pontusxdev"
	LayerPontusxtest Layer = "pontusxtest"
	LayerSapphire    Layer = "sapphire"
)

// Defines values for ProposalState.
const (
	ProposalStateActive   ProposalState = "active"
	ProposalStateFailed   ProposalState = "failed"
	ProposalStatePassed   ProposalState = "passed"
	ProposalStateRejected ProposalState = "rejected"
)

// Defines values for RoothashMessageType.
const (
	RoothashMessageTypeGovernanceCastVote       RoothashMessageType = "governance.cast_vote"
	RoothashMessageTypeGovernanceSubmitProposal RoothashMessageType = "governance.submit_proposal"
	RoothashMessageTypeRegistryUpdateRuntime    RoothashMessageType = "registry.update_runtime"
	RoothashMessageTypeStakingAddEscrow         RoothashMessageType = "staking.add_escrow"
	RoothashMessageTypeStakingReclaimEscrow     RoothashMessageType = "staking.reclaim_escrow"
	RoothashMessageTypeStakingTransfer          RoothashMessageType = "staking.transfer"
	RoothashMessageTypeStakingWithdraw          RoothashMessageType = "staking.withdraw"
)

// Defines values for Runtime.
const (
	RuntimeCipher      Runtime = "cipher"
	RuntimeEmerald     Runtime = "emerald"
	RuntimePontusxdev  Runtime = "pontusxdev"
	RuntimePontusxtest Runtime = "pontusxtest"
	RuntimeSapphire    Runtime = "sapphire"
)

// Defines values for RuntimeEventType.
const (
	RuntimeEventTypeAccountsBurn                     RuntimeEventType = "accounts.burn"
	RuntimeEventTypeAccountsMint                     RuntimeEventType = "accounts.mint"
	RuntimeEventTypeAccountsTransfer                 RuntimeEventType = "accounts.transfer"
	RuntimeEventTypeConsensusAccountsDelegate        RuntimeEventType = "consensus_accounts.delegate"
	RuntimeEventTypeConsensusAccountsDeposit         RuntimeEventType = "consensus_accounts.deposit"
	RuntimeEventTypeConsensusAccountsUndelegateDone  RuntimeEventType = "consensus_accounts.undelegate_done"
	RuntimeEventTypeConsensusAccountsUndelegateStart RuntimeEventType = "consensus_accounts.undelegate_start"
	RuntimeEventTypeConsensusAccountsWithdraw        RuntimeEventType = "consensus_accounts.withdraw"
	RuntimeEventTypeCoreGasUsed                      RuntimeEventType = "core.gas_used"
	RuntimeEventTypeEvmLog                           RuntimeEventType = "evm.log"
)

// Defines values for VerificationLevel.
const (
	VerificationLevelFull    VerificationLevel = "full"
	VerificationLevelPartial VerificationLevel = "partial"
)

// Account A consensus layer account.
type Account struct {
	// Address The staking address for this account.
	Address string `json:"address"`

	// Allowances The allowances made by this account.
	// This field is omitted when listing multiple accounts.
	Allowances []Allowance `json:"allowances"`

	// Available The available balance, in base units.
	Available TextBigInt `json:"available"`

	// Debonding The debonding escrow balance, in base units.
	Debonding TextBigInt `json:"debonding"`

	// DebondingDelegationsBalance The balance of this accounts' (outgoing) debonding delegations, in base units.
	DebondingDelegationsBalance TextBigInt `json:"debonding_delegations_balance"`

	// DelegationsBalance The balance of this accounts' (outgoing) delegations, in base units.
	DelegationsBalance TextBigInt `json:"delegations_balance"`

	// Escrow The active escrow balance, in base units.
	Escrow TextBigInt `json:"escrow"`

	// FirstActivity The second-granular consensus time of the block in which this account was first active.
	// Dates before Cobalt (2021-04-28) are approximate.
	FirstActivity *time.Time `json:"first_activity,omitempty"`

	// Nonce The expected nonce for the next transaction (= last used nonce + 1)
	Nonce int64        `json:"nonce"`
	Stats AccountStats `json:"stats"`
}

// AccountList defines model for AccountList.
type AccountList struct {
	Accounts []Account `json:"accounts"`

	// IsTotalCountClipped Whether total_count is clipped for performance reasons.
	IsTotalCountClipped bool `json:"is_total_count_clipped"`

	// TotalCount The total number of records that match the query, i.e. the number of records
	// the query would return with limit=infinity.
	TotalCount uint64 `json:"total_count"`
}

// AccountStats defines model for AccountStats.
type AccountStats struct {
	// NumTxns The total number of transactions this account was involved with.
	NumTxns uint64 `json:"num_txns"`

	// TotalReceived The total amount of native tokens received, in base units.
	// DEPRECATED: This field might be inaccurate. Nexus is currently not able to track
	// certain actions which subtract/add tokens.
	TotalReceived *TextBigInt `json:"total_received,omitempty"`

	// TotalSent The total amount of native tokens sent, in base units.
	// DEPRECATED: This field might be inaccurate. Nexus is currently not able to track
	// certain actions which subtract/add tokens.
	TotalSent *TextBigInt `json:"total_sent,omitempty"`
}

// ActiveAccounts defines model for ActiveAccounts.
type ActiveAccounts struct {
	// ActiveAccounts The number of active accounts for the 24hour window ending at window_end.
	ActiveAccounts uint64 `json:"active_accounts"`

	// WindowEnd The date for the end of the daily active accounts measurement window.
	WindowEnd time.Time `json:"window_end"`
}

// ActiveAccountsList A list of daily unique active account windows.
type ActiveAccountsList struct {
	WindowSizeSeconds uint32 `json:"window_size_seconds"`

	// Windows The list of daily unique active account windows.
	Windows []ActiveAccounts `json:"windows"`
}

// Address An Oasis-style (bech32) address.
type Address = string

// AddressDerivationContext defines model for AddressDerivationContext.
type AddressDerivationContext string

// AddressPreimage The data from which a consensus-style address (`oasis1...`)
// was derived. Notably, for EVM runtimes like Sapphire,
// this links the Oasis address and the Ethereum address.
//
// Oasis addresses are derived from a piece of data, such as an ed25519
// public key or an Ethereum address. For example, [this](https://github.com/oasisprotocol/oasis-sdk/blob/b37e6da699df331f5a2ac62793f8be099c68469c/client-sdk/go/helpers/address.go#L90-L91)
// is how an Ethereum is converted to an Oasis address. The type of underlying data usually also
// determines how the signatuers for this address are verified.
//
// Consensus supports only "staking addresses" (`context="oasis-core/address: staking"`
// below; always ed25519-backed).
// Runtimes support all types. This means that every consensus address is also
// valid in every runtime. For example, in EVM runtimes, you can use staking
// addresses, but only with Oasis tools (e.g. a wallet); EVM contracts such as
// ERC20 tokens or tools such as Metamask cannot interact with staking addresses.
type AddressPreimage struct {
	// AddressData The base64-encoded data from which the Oasis address was derived.
	// When `context = "oasis-runtime-sdk/address: secp256k1eth"`, this
	// is the Ethereum address (in base64, not hex!).
	AddressData []byte `json:"address_data"`

	// Context The method by which the Oasis address was derived from `address_data`.
	Context AddressDerivationContext `json:"context"`

	// ContextVersion Version of the `context`.
	ContextVersion *int `json:"context_version,omitempty"`
}

// Allowance defines model for Allowance.
type Allowance struct {
	// Address The allowed account.
	Address string `json:"address"`

	// Amount The amount allowed for the allowed account.
	// This field is omitted when listing multiple accounts.
	Amount TextBigInt `json:"amount"`
}

// BareTokenHolder Balance of an account for a specific (implied) runtime and token.
type BareTokenHolder struct {
	// Balance Number of tokens held, in base units.
	Balance TextBigInt `json:"balance"`

	// EthHolderAddress The Ethereum address of the same account holder, if meaningfully defined.
	EthHolderAddress *string `json:"eth_holder_address,omitempty"`

	// HolderAddress The Oasis address of the account holder.
	HolderAddress string `json:"holder_address"`
}

// Block A consensus block.
type Block struct {
	// Epoch The epoch number of the epoch in which the block was produced.
	Epoch int64 `json:"epoch"`

	// GasLimit The gas limit for the block. A gas limit 0 means that the max block gas was unlimited.
	// Blocks from Cobalt, Damask, and early Eden had no gas limit as their sizes were only
	// restricted by byte size until an upgrade during Eden introduced a gas limit.
	GasLimit TextBigInt `json:"gas_limit"`

	// Hash The block header hash.
	Hash string `json:"hash"`

	// Height The block height.
	Height int64 `json:"height"`

	// NumTransactions Number of transactions in the block.
	NumTransactions int32 `json:"num_transactions"`

	// SizeLimit The size limit for the block in bytes.
	SizeLimit *TextBigInt `json:"size_limit,omitempty"`

	// StateRoot The Merkle root of the state tree after applying the block.
	StateRoot string `json:"state_root"`

	// Timestamp The second-granular consensus time.
	Timestamp time.Time `json:"timestamp"`
}

// BlockList defines model for BlockList.
type BlockList struct {
	Blocks []Block `json:"blocks"`

	// IsTotalCountClipped Whether total_count is clipped for performance reasons.
	IsTotalCountClipped bool `json:"is_total_count_clipped"`

	// TotalCount The total number of records that match the query, i.e. the number of records
	// the query would return with limit=infinity.
	TotalCount uint64 `json:"total_count"`
}

// CallFormat defines model for CallFormat.
type CallFormat = common.CallFormat

// ConsensusEvent An event emitted by the consensus layer.
type ConsensusEvent struct {
	// Block The block height at which this event was generated.
	Block int64 `json:"block"`

	// Body The event contents. This spec does not encode the many possible types;
	// instead, see [the Go API](https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/consensus/api/transaction/results#Event) of oasis-core.
	// This object will conform to one of the `*Event` types two levels down
	// the hierarchy, e.g. `TransferEvent` from `Event > staking.Event > TransferEvent`
	Body map[string]interface{} `json:"body"`

	// RoothashRuntime The runtime to which the event relates.
	// Present only for events of type `roothash.*`.
	RoothashRuntime *Runtime `json:"roothash_runtime,omitempty"`

	// RoothashRuntimeId The ID of the runtime to which the event relates, encoded in hex.
	// Present only for events of type `roothash.*`.
	RoothashRuntimeId *string `json:"roothash_runtime_id,omitempty"`

	// RoothashRuntimeRound When applicable, the round in the runtime to which this event
	// relates.
	// Present only for events of type `roothash.*` except for
	// `roothash.execution_discrepancy` before Eden.
	RoothashRuntimeRound *int64 `json:"roothash_runtime_round,omitempty"`

	// TxHash Hash of this event's originating transaction.
	// Absent if the event did not originate from a transaction.
	TxHash *string `json:"tx_hash,omitempty"`

	// TxIndex 0-based index of this event's originating transaction within its block.
	// Absent if the event did not originate from a transaction.
	TxIndex *int32 `json:"tx_index,omitempty"`

	// Type The type of the event.
	Type ConsensusEventType `json:"type"`
}

// ConsensusEventList defines model for ConsensusEventList.
type ConsensusEventList struct {
	Events []ConsensusEvent `json:"events"`

	// IsTotalCountClipped Whether total_count is clipped for performance reasons.
	IsTotalCountClipped bool `json:"is_total_count_clipped"`

	// TotalCount The total number of records that match the query, i.e. the number of records
	// the query would return with limit=infinity.
	TotalCount uint64 `json:"total_count"`
}

// ConsensusEventType defines model for ConsensusEventType.
type ConsensusEventType string

// ConsensusTxMethod defines model for ConsensusTxMethod.
type ConsensusTxMethod string

// DebondingDelegation A debonding delegation.
type DebondingDelegation struct {
	// Amount The amount of tokens delegated in base units.
	Amount TextBigInt `json:"amount"`

	// DebondEnd The epoch at which the debonding ends.
	DebondEnd int64 `json:"debond_end"`

	// Delegator The delegator address.
	Delegator string `json:"delegator"`

	// Shares The shares of tokens delegated.
	Shares TextBigInt `json:"shares"`

	// Validator The delegatee (validator) address.
	Validator string `json:"validator"`
}

// DebondingDelegationList defines model for DebondingDelegationList.
type DebondingDelegationList struct {
	DebondingDelegations []DebondingDelegation `json:"debonding_delegations"`

	// IsTotalCountClipped Whether total_count is clipped for performance reasons.
	IsTotalCountClipped bool `json:"is_total_count_clipped"`

	// TotalCount The total number of records that match the query, i.e. the number of records
	// the query would return with limit=infinity.
	TotalCount uint64 `json:"total_count"`
}

// Delegation A delegation.
type Delegation struct {
	// Amount The amount of tokens delegated in base units.
	Amount TextBigInt `json:"amount"`

	// Delegator The delegator address.
	Delegator string `json:"delegator"`

	// Shares The shares of tokens delegated.
	Shares TextBigInt `json:"shares"`

	// Validator The delegatee (validator) address.
	Validator string `json:"validator"`
}

// DelegationList defines model for DelegationList.
type DelegationList struct {
	Delegations []Delegation `json:"delegations"`

	// IsTotalCountClipped Whether total_count is clipped for performance reasons.
	IsTotalCountClipped bool `json:"is_total_count_clipped"`

	// TotalCount The total number of records that match the query, i.e. the number of records
	// the query would return with limit=infinity.
	TotalCount uint64 `json:"total_count"`
}

// Ed25519PubKey A base64-encoded ed25519 public key.
type Ed25519PubKey = signature.PublicKey

// Entity An entity registered at the consensus layer.
type Entity struct {
	// Address The staking address belonging to this entity; derived from the entity's public key.
	Address string `json:"address"`

	// Id The public key identifying this entity.
	ID string `json:"id"`

	// Nodes The vector of nodes owned by this entity.
	Nodes []string `json:"nodes"`
}

// EntityList defines model for EntityList.
type EntityList struct {
	Entities []Entity `json:"entities"`

	// IsTotalCountClipped Whether total_count is clipped for performance reasons.
	IsTotalCountClipped bool `json:"is_total_count_clipped"`

	// TotalCount The total number of records that match the query, i.e. the number of records
	// the query would return with limit=infinity.
	TotalCount uint64 `json:"total_count"`
}

// Epoch A consensus epoch.
type Epoch struct {
	// EndHeight The (inclusive) height at which this epoch ended. Omitted if the epoch is still active.
	EndHeight *uint64 `json:"end_height,omitempty"`

	// Id The epoch number.
	ID int64 `json:"id"`

	// StartHeight The (inclusive) height at which this epoch started.
	StartHeight uint64 `json:"start_height"`
}

// EpochList defines model for EpochList.
type EpochList struct {
	Epochs []Epoch `json:"epochs"`

	// IsTotalCountClipped Whether total_count is clipped for performance reasons.
	IsTotalCountClipped bool `json:"is_total_count_clipped"`

	// TotalCount The total number of records that match the query, i.e. the number of records
	// the query would return with limit=infinity.
	TotalCount uint64 `json:"total_count"`
}

// Escrow defines model for Escrow.
type Escrow struct {
	// ActiveBalance The amount of tokens that are delegated to this validator account, and are NOT in the process of debonding.
	ActiveBalance *TextBigInt `json:"active_balance,omitempty"`

	// ActiveBalance24 The active_balance of this validator account 24 hours ago.
	ActiveBalance24 *TextBigInt `json:"active_balance_24,omitempty"`

	// ActiveShares The shares of tokens that are delegated to this validator account, and are NOT in the process of debonding.
	ActiveShares *TextBigInt `json:"active_shares,omitempty"`

	// DebondingBalance The amount of tokens that are delegated to this validator account, but are also in the process of debonding (i.e. they will be unstaked within ~2 weeks).
	DebondingBalance *TextBigInt `json:"debonding_balance,omitempty"`

	// DebondingShares The shares of tokens that are delegated to this validator account, but are also in the process of debonding (i.e. they will be unstaked within ~2 weeks).
	DebondingShares *TextBigInt `json:"debonding_shares,omitempty"`

	// NumDelegators The number of accounts that have delegated token to this account.
	NumDelegators *uint64 `json:"num_delegators,omitempty"`

	// SelfDelegationBalance The amount of token this validator has delegated to itself, and are NOT in the process of debonding.
	SelfDelegationBalance *TextBigInt `json:"self_delegation_balance,omitempty"`

	// SelfDelegationShares The shares of tokens this validator has delegated to itself, and are NOT in the process of debonding.
	SelfDelegationShares *TextBigInt `json:"self_delegation_shares,omitempty"`
}

// EthOrOasisAddress defines model for EthOrOasisAddress.
type EthOrOasisAddress = string

// EvmAbiParam A decoded parameter of an event or error emitted from an EVM runtime.
// Values of EVM type `int128`, `uint128`, `int256`, `uint256`, `fixed`, and `ufixed` are represented as strings.
// Values of EVM type `address` and `address payable` are represented as lowercase hex strings with a "0x" prefix.
// Values of EVM type `bytes` and `bytes<N>` are represented as base64 strings.
// Values of other EVM types (integer types, strings, arrays, etc.) are represented as their JSON counterpart.
type EvmAbiParam struct {
	// EvmType The solidity type of the parameter.
	EvmType string `json:"evm_type"`

	// Name The parameter name.
	Name string `json:"name"`

	// Value The parameter value.
	Value interface{} `json:"value"`
}

// EvmEventToken Details about the EVM token involved in the event, if any.
type EvmEventToken struct {
	// Decimals The number of least significant digits in base units that should be displayed as
	// decimals when displaying tokens. `tokens = base_units / (10**decimals)`.
	// Affects display only. Often equals 18, to match ETH.
	Decimals *int `json:"decimals,omitempty"`

	// Symbol Symbol of the token, as provided by token contract's `symbol()` method.
	Symbol *string       `json:"symbol,omitempty"`
	Type   *EvmTokenType `json:"type,omitempty"`
}

// EvmNft defines model for EvmNft.
type EvmNft struct {
	// Description Describes the asset which this NFT represents
	Description *string `json:"description,omitempty"`

	// Id The instance ID of this NFT within the collection represented by `token`.
	Id TextBigInt `json:"id"`

	// Image A URI pointing to a resource with mime type image/* representing
	// the asset which this NFT represents. (Additional
	// non-descriptive text from ERC-721 omitted.)
	Image *string `json:"image,omitempty"`

	// Metadata A metadata document for this NFT instance.
	// Currently only ERC-721 is supported, where the document is an Asset Metadata from the ERC721 Metadata JSON Schema.
	Metadata         *interface{} `json:"metadata,omitempty"`
	MetadataAccessed *string      `json:"metadata_accessed,omitempty"`
	MetadataUri      *string      `json:"metadata_uri,omitempty"`

	// Name Identifies the asset which this NFT represents
	Name *string `json:"name,omitempty"`

	// NumTransfers The total number of transfers of this NFT instance.
	NumTransfers *int64 `json:"num_transfers,omitempty"`

	// Owner The Oasis address of this NFT instance's owner.
	Owner *Address `json:"owner,omitempty"`

	// OwnerEth The Ethereum address of this NFT instance's owner.
	OwnerEth *string  `json:"owner_eth,omitempty"`
	Token    EvmToken `json:"token"`
}

// EvmNftList defines model for EvmNftList.
type EvmNftList struct {
	// EvmNfts A list of L2 EVM NFT (ERC-721, ...) instances.
	EvmNfts []EvmNft `json:"evm_nfts"`

	// IsTotalCountClipped Whether total_count is clipped for performance reasons.
	IsTotalCountClipped bool `json:"is_total_count_clipped"`

	// TotalCount The total number of records that match the query, i.e. the number of records
	// the query would return with limit=infinity.
	TotalCount uint64 `json:"total_count"`
}

// EvmToken defines model for EvmToken.
type EvmToken struct {
	// ContractAddr The Oasis address of this token's contract.
	ContractAddr string `json:"contract_addr"`

	// Decimals The number of least significant digits in base units that should be displayed as
	// decimals when displaying tokens. `tokens = base_units / (10**decimals)`.
	// Affects display only. Often equals 18, to match ETH.
	Decimals *int `json:"decimals,omitempty"`

	// EthContractAddr The Ethereum address of this token's contract.
	EthContractAddr string `json:"eth_contract_addr"`

	// IsVerified Whether the contract has been successfully verified by Sourcify.
	// Additional information on verified contracts is available via
	// the `/{runtime}/accounts/{address}` endpoint.
	// DEPRECATED: This field will be removed in the future in favor of verification_level
	IsVerified bool `json:"is_verified"`

	// Name Name of the token, as provided by token contract's `name()` method.
	Name *string `json:"name,omitempty"`

	// NumHolders The number of addresses that have a nonzero balance of this token.
	NumHolders int64 `json:"num_holders"`

	// NumTransfers The total number of transfers of this token.
	NumTransfers *int64 `json:"num_transfers,omitempty"`

	// Symbol Symbol of the token, as provided by token contract's `symbol()` method.
	Symbol *string `json:"symbol,omitempty"`

	// TotalSupply The total number of base units available.
	TotalSupply *TextBigInt `json:"total_supply,omitempty"`

	// Type The heuristically determined interface that the token contract implements.
	// A less specialized variant of the token might be detected; for example, an
	// ERC-1363 token might be labeled as ERC-20 here. If the type cannot be
	// detected or is not supported, this field will be null/absent.
	Type              EvmTokenType       `json:"type"`
	VerificationLevel *VerificationLevel `json:"verification_level,omitempty"`
}

// EvmTokenList defines model for EvmTokenList.
type EvmTokenList struct {
	// EvmTokens A list of L2 EVM tokens (ERC-20, ERC-721, ...).
	EvmTokens []EvmToken `json:"evm_tokens"`

	// IsTotalCountClipped Whether total_count is clipped for performance reasons.
	IsTotalCountClipped bool `json:"is_total_count_clipped"`

	// TotalCount The total number of records that match the query, i.e. the number of records
	// the query would return with limit=infinity.
	TotalCount uint64 `json:"total_count"`
}

// EvmTokenType The type of a EVM token.
type EvmTokenType string

// Layer defines model for Layer.
type Layer string

// List defines model for List.
type List struct {
	// IsTotalCountClipped Whether total_count is clipped for performance reasons.
	IsTotalCountClipped bool `json:"is_total_count_clipped"`

	// TotalCount The total number of records that match the query, i.e. the number of records
	// the query would return with limit=infinity.
	TotalCount uint64 `json:"total_count"`
}

// Node A node registered at the consensus layer.
type Node struct {
	// ConsensusPubkey The unique identifier of this node as a consensus member
	ConsensusPubkey string `json:"consensus_pubkey"`

	// EntityId The public key identifying the entity controlling this node.
	EntityID string `json:"entity_id"`

	// Expiration The epoch in which this node's commitment expires.
	Expiration int64 `json:"expiration"`

	// Id The public key identifying this node.
	ID string `json:"id"`

	// P2pPubkey The unique identifier of this node on the P2P transport.
	P2PPubkey string `json:"p2p_pubkey"`

	// Roles A bitmask representing this node's roles.
	Roles string `json:"roles"`

	// TlsNextPubkey The public key that will be used for establishing TLS connections
	// upon rotation.
	TLSNextPubkey string `json:"tls_next_pubkey"`

	// TlsPubkey The public key used for establishing TLS connections.
	TLSPubkey string `json:"tls_pubkey"`
}

// NodeList defines model for NodeList.
type NodeList struct {
	EntityID string `json:"entity_id"`

	// IsTotalCountClipped Whether total_count is clipped for performance reasons.
	IsTotalCountClipped bool   `json:"is_total_count_clipped"`
	Nodes               []Node `json:"nodes"`

	// TotalCount The total number of records that match the query, i.e. the number of records
	// the query would return with limit=infinity.
	TotalCount uint64 `json:"total_count"`
}

// Proposal A governance proposal.
type Proposal struct {
	// Cancels The proposal to cancel, if this proposal proposes
	// cancelling an existing proposal.
	Cancels *int64 `json:"cancels,omitempty"`

	// ClosesAt The epoch at which voting for this proposal will close.
	ClosesAt int64 `json:"closes_at"`

	// CreatedAt The epoch at which this proposal was created.
	CreatedAt int64 `json:"created_at"`

	// Deposit The deposit attached to this proposal.
	Deposit TextBigInt `json:"deposit"`

	// Description The (optional) description of the proposal.
	Description *string `json:"description,omitempty"`

	// Epoch The epoch at which the proposed upgrade will happen.
	Epoch *uint64 `json:"epoch,omitempty"`

	// Handler The name of the upgrade handler.
	Handler *string `json:"handler,omitempty"`

	// Id The unique identifier of the proposal.
	ID uint64 `json:"id"`

	// InvalidVotes The number of invalid votes for this proposal, after tallying.
	InvalidVotes TextBigInt `json:"invalid_votes"`

	// ParametersChange The parameters change proposal body. This spec does not encode the many possible types; instead, see [the Go API](https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go) of oasis-core. This object will conform to one of the `ConsensusParameterChanges` types, depending on the `parameters_change_module`.
	ParametersChange *interface{} `json:"parameters_change,omitempty"`

	// ParametersChangeModule The name of the module whose parameters are to be changed
	// by this 'parameters_change' proposal.
	ParametersChangeModule *string       `json:"parameters_change_module,omitempty"`
	State                  ProposalState `json:"state"`

	// Submitter The staking address of the proposal submitter.
	Submitter string          `json:"submitter"`
	Target    *ProposalTarget `json:"target,omitempty"`

	// Title The (optional) title of the proposal.
	Title *string `json:"title,omitempty"`
}

// ProposalList defines model for ProposalList.
type ProposalList struct {
	// IsTotalCountClipped Whether total_count is clipped for performance reasons.
	IsTotalCountClipped bool       `json:"is_total_count_clipped"`
	Proposals           []Proposal `json:"proposals"`

	// TotalCount The total number of records that match the query, i.e. the number of records
	// the query would return with limit=infinity.
	TotalCount uint64 `json:"total_count"`
}

// ProposalState The state of the proposal.
type ProposalState string

// ProposalTarget The target propotocol versions for this upgrade proposal.
type ProposalTarget struct {
	ConsensusProtocol        *string `json:"consensus_protocol,omitempty"`
	RuntimeCommitteeProtocol *string `json:"runtime_committee_protocol,omitempty"`
	RuntimeHostProtocol      *string `json:"runtime_host_protocol,omitempty"`
}

// ProposalVote defines model for ProposalVote.
type ProposalVote struct {
	// Address The staking address casting this vote.
	Address string `json:"address"`

	// Height The block height at which this vote was recorded.
	Height *int64 `json:"height,omitempty"`

	// Timestamp The second-granular consensus time of the block in which this vote was cast.
	Timestamp *time.Time `json:"timestamp,omitempty"`

	// Vote The vote cast.
	Vote string `json:"vote"`
}

// ProposalVotes defines model for ProposalVotes.
type ProposalVotes struct {
	// IsTotalCountClipped Whether total_count is clipped for performance reasons.
	IsTotalCountClipped bool `json:"is_total_count_clipped"`

	// ProposalId The unique identifier of the proposal.
	ProposalID uint64 `json:"proposal_id"`

	// TotalCount The total number of records that match the query, i.e. the number of records
	// the query would return with limit=infinity.
	TotalCount uint64 `json:"total_count"`

	// Votes The list of votes for the proposal.
	Votes []ProposalVote `json:"votes"`
}

// RoothashMessage defines model for RoothashMessage.
type RoothashMessage struct {
	// Body The "body" of a message is a structure within the
	// `github.com/oasisprotocol/oasis-core/go/roothash/api/message`
	// `Message` structure
	// (https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/roothash/api/message#Message).
	// For example, if the type is `staking.withdraw`, the body is the Go
	// `Message` structure's `.Staking.Withdraw` field, which is a
	// `github.com/oasisprotocol/oasis-core/go/staking/api` `Withdraw`
	// structure
	// (https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/staking/api#Withdraw),
	// with `from` and `amount` fields in JSON.
	Body *map[string]interface{} `json:"body,omitempty"`

	// ErrorCode If executing this message resulted in an error, this is the
	// error's code.
	ErrorCode *int32 `json:"error_code,omitempty"`

	// ErrorModule If executing this message resulted in an error, this is the
	// error's module.
	ErrorModule *string `json:"error_module,omitempty"`

	// Index The 0-based index of this message in the block.
	Index int32 `json:"index"`

	// Result A result value that consensus provided after executing this
	// message. These aren't centrally registered anywhere, so look at
	// the consensus apps' `ExecuteMessage`
	// (https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/consensus/cometbft/api#MessageSubscriber)
	// implementations to see what they return. For example, a
	// `staking.withdraw` type message gives a
	// `github.com/oasisprotocol/oasis-core/go/staking/api`
	// `WithdrawResult` structure as its result
	// (`https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/staking/api#WithdrawResult`)
	// with `owner`, `beneficiary`, `allowance`, and `amount_change`
	// fields.
	Result *interface{} `json:"result,omitempty"`

	// Round The block round when the runtime sent this message.
	Round int64 `json:"round"`

	// Runtime The runtime that sent this message.
	Runtime string `json:"runtime"`

	// Type The type of thies message.
	Type *RoothashMessageType `json:"type,omitempty"`
}

// RoothashMessageList defines model for RoothashMessageList.
type RoothashMessageList struct {
	// IsTotalCountClipped Whether total_count is clipped for performance reasons.
	IsTotalCountClipped bool              `json:"is_total_count_clipped"`
	RoothashMessages    []RoothashMessage `json:"roothash_messages"`

	// TotalCount The total number of records that match the query, i.e. the number of records
	// the query would return with limit=infinity.
	TotalCount uint64 `json:"total_count"`
}

// RoothashMessageType defines model for RoothashMessageType.
type RoothashMessageType string

// Runtime defines model for Runtime.
type Runtime string

// RuntimeAccount defines model for RuntimeAccount.
type RuntimeAccount struct {
	// Address The staking address for this account.
	Address         string           `json:"address"`
	AddressPreimage *AddressPreimage `json:"address_preimage,omitempty"`

	// Balances The balance(s) of this account in this runtime. Most runtimes use only one denomination, and thus
	// produce only one balance here. These balances do not include "layer (n+1) tokens", i.e. tokens
	// managed by smart contracts deployed in this runtime. For example, in EVM-compatible runtimes,
	// this does not include ERC-20 tokens
	Balances []RuntimeSdkBalance `json:"balances"`

	// EvmBalances The balances of this account in each runtime, as managed by EVM smart contracts (notably, ERC-20).
	// NOTE: This field is limited to 1000 entries. If you need more, please let us know in a GitHub issue.
	EvmBalances []RuntimeEvmBalance `json:"evm_balances"`

	// EvmContract Data on the EVM smart contract associated with this account address. Only present for accounts
	// that represent a smart contract on EVM.
	EvmContract *RuntimeEvmContract `json:"evm_contract,omitempty"`
	Stats       AccountStats        `json:"stats"`
}

// RuntimeBlock A ParaTime block.
type RuntimeBlock struct {
	// GasUsed The total gas used by all transactions in the block.
	GasUsed int64 `json:"gas_used"`

	// Hash The block header hash.
	Hash string `json:"hash"`

	// NumTransactions The number of transactions in the block.
	NumTransactions int32 `json:"num_transactions"`

	// Round The block round.
	Round int64 `json:"round"`

	// Size The total byte size of all transactions in the block.
	Size int32 `json:"size"`

	// Timestamp The second-granular consensus time.
	Timestamp time.Time `json:"timestamp"`
}

// RuntimeBlockList defines model for RuntimeBlockList.
type RuntimeBlockList struct {
	Blocks []RuntimeBlock `json:"blocks"`

	// IsTotalCountClipped Whether total_count is clipped for performance reasons.
	IsTotalCountClipped bool `json:"is_total_count_clipped"`

	// TotalCount The total number of records that match the query, i.e. the number of records
	// the query would return with limit=infinity.
	TotalCount uint64 `json:"total_count"`
}

// RuntimeEvent An event emitted by the runtime layer
type RuntimeEvent struct {
	// Body The decoded event contents, possibly augmented with additional address info.
	// This spec does not encode the many possible types; instead, see [the Go API](https://pkg.go.dev/github.com/oasisprotocol/oasis-sdk/client-sdk/go/modules).
	// This object will conform to one of the `*Event` types two levels down
	// the hierarchy (e.g. `MintEvent` from `accounts > Event > MintEvent`),
	// OR `evm > Event`. For object fields that specify an oasis-style address, Nexus
	// will add a field specifying the corresponding Ethereum address, if known. Currently,
	// the only such possible fields are `from_eth`, `to_eth`, and `owner_eth`.
	Body map[string]interface{} `json:"body"`

	// EthTxHash Ethereum trasnsaction hash of this event's originating transaction.
	// Absent if the event did not originate from an EVM transaction.
	EthTxHash *string `json:"eth_tx_hash,omitempty"`

	// EvmLogName If the event type is `evm.log`, this field describes the human-readable type of
	// evm event, e.g. `Transfer`.
	// Absent if the event type is not `evm.log`.
	EvmLogName *string `json:"evm_log_name,omitempty"`

	// EvmLogParams The decoded `evm.log` event data.
	// Absent if the event type is not `evm.log`.
	EvmLogParams *[]EvmAbiParam `json:"evm_log_params,omitempty"`
	EvmToken     *EvmEventToken `json:"evm_token,omitempty"`

	// Round The block height at which this event was generated.
	Round int64 `json:"round"`

	// Timestamp The second-granular consensus time of this event's block.
	Timestamp time.Time `json:"timestamp"`

	// TxHash Hash of this event's originating transaction.
	// Absent if the event did not originate from a transaction.
	TxHash *string `json:"tx_hash,omitempty"`

	// TxIndex 0-based index of this event's originating transaction within its block.
	// Absent if the event did not originate from a transaction.
	TxIndex *int32 `json:"tx_index,omitempty"`

	// Type The type of the event.
	Type RuntimeEventType `json:"type"`
}

// RuntimeEventList defines model for RuntimeEventList.
type RuntimeEventList struct {
	Events []RuntimeEvent `json:"events"`

	// IsTotalCountClipped Whether total_count is clipped for performance reasons.
	IsTotalCountClipped bool `json:"is_total_count_clipped"`

	// TotalCount The total number of records that match the query, i.e. the number of records
	// the query would return with limit=infinity.
	TotalCount uint64 `json:"total_count"`
}

// RuntimeEventType defines model for RuntimeEventType.
type RuntimeEventType string

// RuntimeEvmBalance Balance of an account for a specific runtime and EVM token.
type RuntimeEvmBalance struct {
	// Balance Number of tokens held, in base units.
	Balance TextBigInt `json:"balance"`

	// TokenContractAddr The Oasis address of this token's contract.
	TokenContractAddr string `json:"token_contract_addr"`

	// TokenContractAddrEth The EVM address of this token's contract.
	TokenContractAddrEth string `json:"token_contract_addr_eth"`

	// TokenDecimals The number of decimals of precision for this token.
	TokenDecimals int `json:"token_decimals"`

	// TokenName The name of the token. Not guaranteed to be unique across distinct EVM tokens.
	TokenName *string `json:"token_name,omitempty"`

	// TokenSymbol The token ticker symbol. Not guaranteed to be unique across distinct EVM tokens.
	TokenSymbol *string      `json:"token_symbol,omitempty"`
	TokenType   EvmTokenType `json:"token_type"`
}

// RuntimeEvmContract defines model for RuntimeEvmContract.
type RuntimeEvmContract struct {
	// CreationBytecode The creation bytecode of the smart contract. This includes the constructor logic
	// and the constructor parameters. When run, this code generates the runtime bytecode.
	// Can be omitted for contracts that were created by another contract, as opposed
	// to a direct `Create` call.
	CreationBytecode *[]byte `json:"creation_bytecode,omitempty"`

	// CreationTx The Oasis cryptographic hash of the transaction that created the smart contract.
	// Can be omitted for contracts that were created by another contract, as opposed
	// to a direct `Create` call.
	CreationTx *string `json:"creation_tx,omitempty"`

	// EthCreationTx The Ethereum transaction hash of the transaction in `creation_tx`.
	// Encoded as a lowercase hex string.
	EthCreationTx *string `json:"eth_creation_tx,omitempty"`

	// GasUsed The total amount of gas used to create or call this contract.
	GasUsed uint64 `json:"gas_used"`

	// RuntimeBytecode The runtime bytecode of the smart contract. This is the code stored on-chain that
	// describes a smart contract. Every contract has this info, but Nexus fetches
	// it separately, so the field may be missing for very fresh contracts (or if the fetching
	// process is stalled).
	RuntimeBytecode *[]byte `json:"runtime_bytecode,omitempty"`

	// Verification Additional information obtained from contract verification. Only available for smart
	// contracts that have been verified successfully by Sourcify.
	Verification *RuntimeEvmContractVerification `json:"verification,omitempty"`
}

// RuntimeEvmContractVerification defines model for RuntimeEvmContractVerification.
type RuntimeEvmContractVerification struct {
	// CompilationMetadata The smart contract's [metadata.json](https://docs.soliditylang.org/en/latest/metadata.html) file in JSON format as defined by Solidity.
	// Includes the smart contract's [ABI](https://docs.soliditylang.org/en/develop/abi-spec.html).
	CompilationMetadata *map[string]interface{} `json:"compilation_metadata,omitempty"`

	// SourceFiles Array of all contract source files, in JSON format as returned by [Sourcify](https://sourcify.dev/server/api-docs/#/Repository/get_files_any__chain___address_).
	SourceFiles       *[]map[string]interface{} `json:"source_files,omitempty"`
	VerificationLevel *VerificationLevel        `json:"verification_level,omitempty"`
}

// RuntimeSdkBalance Balance of an account for a specific runtime and oasis-sdk token (e.g. ROSE).
type RuntimeSdkBalance struct {
	// Balance Number of tokens held, in base units.
	Balance TextBigInt `json:"balance"`

	// TokenDecimals The number of decimals of precision for this token.
	TokenDecimals int `json:"token_decimals"`

	// TokenSymbol The token ticker symbol. Unique across all oasis-sdk tokens in the same runtime.
	TokenSymbol string `json:"token_symbol"`
}

// RuntimeStatus defines model for RuntimeStatus.
type RuntimeStatus struct {
	// ActiveNodes The number of compute nodes that are registered and can run the runtime.
	ActiveNodes int `json:"active_nodes"`

	// LatestBlock The height of the most recent indexed block (also sometimes referred to as "round") for this runtime. Query a synced Oasis node for the latest block produced.
	LatestBlock int64 `json:"latest_block"`

	// LatestBlockTime The RFC 3339 formatted consensus time of when the latest indexed block for this runtime was produced.
	LatestBlockTime time.Time `json:"latest_block_time"`

	// LatestUpdateAgeMs The number of milliseconds since Nexus processed the latest block.
	LatestUpdateAgeMs int64 `json:"latest_update_age_ms"`
}

// RuntimeTransaction A runtime transaction.
type RuntimeTransaction struct {
	// Amount A reasonable "amount" associated with this transaction, if
	// applicable. The meaning varies based on the transaction method.
	// Usually in native denomination, ParaTime units. As a string.
	Amount *string `json:"amount,omitempty"`

	// AmountSymbol The denomination of the "amount" associated with this transaction, if applicable.
	AmountSymbol *string `json:"amount_symbol,omitempty"`

	// Body The method call body. May be null if the transaction was malformed.
	Body *map[string]interface{} `json:"body,omitempty"`

	// ChargedFee The fee that was charged for the transaction execution (total, native denomination,
	// ParaTime base units, as a string).
	// For EVM transactions this is calculated as `gas_price * gas_used`, where `gas_price = fee / gas_limit`, for compatibility with Ethereum.
	// For other transactions this equals to `fee`.
	ChargedFee string `json:"charged_fee"`

	// EncryptionEnvelope The data relevant to the encrypted transaction. Only present for encrypted
	// transactions in confidential EVM runtimes like Sapphire.
	// Note: The term "envelope" in this context refers to the [Oasis-style encryption envelopes](https://github.com/oasisprotocol/oasis-sdk/blob/c36a7ee194abf4ca28fdac0edbefe3843b39bf69/runtime-sdk/src/types/callformat.rs)
	// which differ slightly from [digital envelopes](hhttps://en.wikipedia.org/wiki/Hybrid_cryptosystem#Envelope_encryption).
	EncryptionEnvelope *RuntimeTransactionEncryptionEnvelope `json:"encryption_envelope,omitempty"`

	// Error Error details of a failed transaction.
	Error *TxError `json:"error,omitempty"`

	// EthHash The Ethereum cryptographic hash of this transaction's encoding.
	// Absent for non-Ethereum-format transactions.
	EthHash *string `json:"eth_hash,omitempty"`

	// EvmFnName The name of the smart contract function called by the transaction.
	// Only present for `evm.log` transaction calls to contracts that have been verified.
	EvmFnName *string `json:"evm_fn_name,omitempty"`

	// EvmFnParams The decoded parameters with which the smart contract function was called.
	// Only present for `evm.log` transaction calls to contracts that have been verified.
	EvmFnParams *[]EvmAbiParam `json:"evm_fn_params,omitempty"`

	// Fee The fee that this transaction's sender committed to pay to execute
	// it (total ParaTime base units, as a string).
	Fee string `json:"fee"`

	// FeeProxyId the base64-encoded id of the fee proxy.
	FeeProxyId *[]byte `json:"fee_proxy_id,omitempty"`

	// FeeProxyModule The module of the fee proxy.
	FeeProxyModule *string `json:"fee_proxy_module,omitempty"`

	// FeeSymbol The denomination of the fee.
	FeeSymbol string `json:"fee_symbol"`

	// GasLimit The maximum gas that this transaction's sender committed to use to
	// execute it.
	GasLimit uint64 `json:"gas_limit"`

	// GasUsed The total gas used by the transaction.
	GasUsed uint64 `json:"gas_used"`

	// Hash The Oasis cryptographic hash of this transaction's encoding.
	Hash string `json:"hash"`

	// Index The 0-based index of this transaction in the block.
	Index int64 `json:"index"`

	// IsLikelyNativeTokenTransfer Whether this transaction likely represents a native token transfer.
	// This is based on a heuristic, and can change at any time without warning and possibly without updating the documentation.
	// The current heuristic sets this to `true` for:
	//  - Transactions with method "accounts.Transfer". Those are always native token transfers.
	//  - Transactions with method "evm.Call" that have no `data` field in their `body`. Those tend to be transfers, but the runtimes provides no reliable visibility into whether a transfer happened.
	// Note: Other transactions with method "evm.Call", and possibly "evm.Create", may also be (or include) native token transfers. The heuristic will be `false` for those.
	IsLikelyNativeTokenTransfer *bool `json:"is_likely_native_token_transfer,omitempty"`

	// Method The method that was called. Defined by the runtime. In theory, this could be any string as the runtimes evolve.
	// In practice, Nexus currently expects only the following methods:
	//   - "accounts.Transfer"
	//   - "consensus.Deposit"
	//   - "consensus.Withdraw"
	//   - "consensus.Delegate"
	//   - "consensus.Undelegate"
	//   - "evm.Create"
	//   - "evm.Call"
	// May be null if the transaction was malformed or encrypted.
	Method *string `json:"method,omitempty"`

	// Nonce0 The nonce used with this transaction's 0th signer, to prevent replay.
	Nonce0 uint64 `json:"nonce_0"`

	// Round The block round at which this transaction was executed.
	Round int64 `json:"round"`

	// Sender0 The Oasis address of this transaction's 0th signer.
	// Unlike Ethereum, Oasis natively supports multiple-signature transactions.
	// However, the great majority of transactions only have a single signer in practice.
	// Retrieving the other signers is currently not supported by this API.
	Sender0 Address `json:"sender_0"`

	// Sender0Eth The Ethereum address of this transaction's 0th signer.
	Sender0Eth *string `json:"sender_0_eth,omitempty"`

	// Size The total byte size of the transaction.
	Size int32 `json:"size"`

	// Success Whether this transaction successfully executed.
	// Can be absent (meaning "unknown") for confidential runtimes.
	Success *bool `json:"success,omitempty"`

	// Timestamp The second-granular consensus time when this tx's block was proposed.
	Timestamp time.Time `json:"timestamp"`

	// To A reasonable "to" Oasis address associated with this transaction,
	// if applicable. The meaning varies based on the transaction method. Some notable examples:
	//   - For `method = "accounts.Transfer"`, this is the paratime account receiving the funds.
	//   - For `method = "consensus.Deposit"`, this is the paratime account receiving the funds.
	//   - For `method = "consensus.Withdraw"`, this is the consensus (!) account receiving the funds.
	//   - For `method = "consensus.Delegate"`, this is the consensus (!) account receiving the funds.
	//   - For `method = "consensus.Undelegate"`, this is the consensus (!) account to which funds were previously delegated. Note that this corresponds with the `.from` field in the transaction body.
	//   - For `method = "evm.Create"`, this is the address of the newly created smart contract.
	//   - For `method = "evm.Call"`, this is the address of the called smart contract
	To *Address `json:"to,omitempty"`

	// ToEth A reasonable "to" Ethereum address associated with this transaction,
	ToEth *string `json:"to_eth,omitempty"`
}

// RuntimeTransactionEncryptionEnvelope defines model for RuntimeTransactionEncryptionEnvelope.
type RuntimeTransactionEncryptionEnvelope struct {
	// Data The base64-encoded encrypted transaction data.
	Data *[]byte `json:"data,omitempty"`

	// DataNonce The base64-encoded nonce used to encrypt the transaction data.
	DataNonce *[]byte `json:"data_nonce,omitempty"`

	// Format The format of the encrypted evm transaction envelope.
	Format CallFormat `json:"format"`

	// PublicKey The base64-encoded public key used to encrypt the transaction.
	PublicKey *[]byte `json:"public_key,omitempty"`

	// Result The base64-encoded encrypted result data.
	Result *[]byte `json:"result,omitempty"`

	// ResultNonce The base64-encoded nonce used to encrypt the transaction results.
	ResultNonce *[]byte `json:"result_nonce,omitempty"`
}

// RuntimeTransactionList defines model for RuntimeTransactionList.
type RuntimeTransactionList struct {
	// IsTotalCountClipped Whether total_count is clipped for performance reasons.
	IsTotalCountClipped bool `json:"is_total_count_clipped"`

	// TotalCount The total number of records that match the query, i.e. the number of records
	// the query would return with limit=infinity.
	TotalCount   uint64               `json:"total_count"`
	Transactions []RuntimeTransaction `json:"transactions"`
}

// StakingAddress An Oasis-style (bech32) address.
type StakingAddress = staking.Address

// Status defines model for Status.
type Status struct {
	// LatestBlock The height of the most recent indexed block. Compare with latest_node_block to measure
	// how far behind Nexus is from the chain.
	LatestBlock int64 `json:"latest_block"`

	// LatestBlockTime The RFC 3339 formatted consensus time of when the most recently indexed block was produced.
	LatestBlockTime time.Time `json:"latest_block_time"`

	// LatestNodeBlock The height of the most recently produced block on-chain as seen by Nexus.
	LatestNodeBlock int64 `json:"latest_node_block"`

	// LatestUpdateAgeMs The number of milliseconds since Nexus processed the latest block.
	LatestUpdateAgeMs int64 `json:"latest_update_age_ms"`
}

// TextBigInt defines model for TextBigInt.
type TextBigInt = common.BigInt

// TokenHolderList defines model for TokenHolderList.
type TokenHolderList struct {
	Holders []BareTokenHolder `json:"holders"`

	// IsTotalCountClipped Whether total_count is clipped for performance reasons.
	IsTotalCountClipped bool `json:"is_total_count_clipped"`

	// TotalCount The total number of records that match the query, i.e. the number of records
	// the query would return with limit=infinity.
	TotalCount uint64 `json:"total_count"`
}

// Transaction A consensus transaction.
type Transaction struct {
	// Block The block height at which this transaction was executed.
	Block int64 `json:"block"`

	// Body The method call body. This spec does not encode the many possible types; instead, see [the Go API](https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go) of oasis-core. This object will conform to one of the types passed to variable instantiations using `NewMethodName` two levels down the hierarchy, e.g. `MethodTransfer` from `oasis-core/go/staking/api` seen [here](https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go@v0.2300.10/staking/api#pkg-variables).
	Body map[string]interface{} `json:"body"`

	// Error Error details of a failed transaction.
	Error *TxError `json:"error,omitempty"`

	// Fee The fee that this transaction's sender committed
	// to pay to execute it.
	Fee TextBigInt `json:"fee"`

	// GasLimit The maximum gas that a transaction can use.
	GasLimit TextBigInt `json:"gas_limit"`

	// Hash The cryptographic hash of this transaction's encoding.
	Hash string `json:"hash"`

	// Index 0-based index of this transaction in its block
	Index int32 `json:"index"`

	// Method The method that was called.
	Method ConsensusTxMethod `json:"method"`

	// Nonce The nonce used with this transaction, to prevent replay.
	Nonce int64 `json:"nonce"`

	// Sender The address of who sent this transaction.
	Sender string `json:"sender"`

	// Success Whether this transaction successfully executed.
	Success bool `json:"success"`

	// Timestamp The second-granular consensus time of this tx's block, i.e. roughly when the
	// [block was proposed](https://github.com/tendermint/tendermint/blob/v0.34.x/spec/core/data_structures.md#header).
	Timestamp time.Time `json:"timestamp"`
}

// TransactionList defines model for TransactionList.
type TransactionList struct {
	// IsTotalCountClipped Whether total_count is clipped for performance reasons.
	IsTotalCountClipped bool `json:"is_total_count_clipped"`

	// TotalCount The total number of records that match the query, i.e. the number of records
	// the query would return with limit=infinity.
	TotalCount   uint64        `json:"total_count"`
	Transactions []Transaction `json:"transactions"`
}

// TxError defines model for TxError.
type TxError struct {
	// Code The status code of a failed transaction.
	Code uint32 `json:"code"`

	// Message The message of a failed transaction.
	// This field, like `code` and `module`, can represent an error that originated
	// anywhere in the paratime, i.e. either inside or outside a smart contract.
	//
	// A common special case worth calling out: When the paratime is
	// EVM-compatible (e.g. Emerald or Sapphire) and the error originates
	// inside a smart contract (using `revert` in solidity), the following
	// will be true:
	// - `module` will be "evm" and `code` will be 8; see [here](https://github.com/oasisprotocol/oasis-sdk/blob/runtime-sdk/v0.8.3/runtime-sdk/modules/evm/src/lib.rs#L128) for other possible errors in the `evm` module.
	// - `message` will contain the best-effort human-readable revert reason.
	Message *string `json:"message,omitempty"`

	// Module The module of a failed transaction.
	Module *string `json:"module,omitempty"`

	// RevertParams The error parameters, as decoded using the contract abi. Present only when
	// - the error originated from within a smart contract (e.g. via `revert` in Solidity), and
	// - the contract is verified or the revert reason is a plain String.
	// If this field is present, `message` will include the name of the error, e.g. 'InsufficentBalance'.
	// Note that users should be cautious when evaluating error data since the
	// data origin is not tracked and error information can be faked.
	RevertParams *[]EvmAbiParam `json:"revert_params,omitempty"`
}

// TxVolume defines model for TxVolume.
type TxVolume struct {
	// TxVolume The transaction volume for this window.
	TxVolume uint64 `json:"tx_volume"`

	// WindowEnd The end timestamp for this daily transaction volume measurement.
	WindowEnd time.Time `json:"window_end"`
}

// TxVolumeList A list of daily transaction volumes.
type TxVolumeList struct {
	WindowSizeSeconds uint32 `json:"window_size_seconds"`

	// Windows The list of daily transaction volumes.
	Windows []TxVolume `json:"windows"`
}

// Validator An validator registered at the consensus layer.
type Validator struct {
	// Active Whether the entity has a node that is registered for being a validator, node is up to date, and has successfully registered itself. It may or may not be part of validator set.
	Active                 bool                     `json:"active"`
	CurrentCommissionBound ValidatorCommissionBound `json:"current_commission_bound"`

	// CurrentRate Commission rate.
	CurrentRate uint64 `json:"current_rate"`

	// EntityAddress The staking address identifying this validator.
	EntityAddress string `json:"entity_address"`

	// EntityId The public key identifying this validator.
	EntityID string `json:"entity_id"`

	// Escrow The escrow account data for this validator.
	Escrow Escrow `json:"escrow"`

	// InValidatorSet Whether the entity is part of the validator set (top <scheduler.params.max_validators> by stake among active entities).
	InValidatorSet bool            `json:"in_validator_set"`
	Media          *ValidatorMedia `json:"media,omitempty"`

	// NodeId The public key identifying this validator's node.
	NodeID *string `json:"node_id,omitempty"`

	// Rank The rank of the validator, determined by voting power.
	Rank uint64 `json:"rank"`

	// StartDate The second-granular consensus time.
	StartDate time.Time `json:"start_date"`

	// VotingPower The voting power of this validator.
	VotingPower int64 `json:"voting_power"`

	// VotingPowerTotal The total voting power across all validators.
	VotingPowerTotal int64 `json:"voting_power_total"`
}

// ValidatorCommissionBound defines model for ValidatorCommissionBound.
type ValidatorCommissionBound struct {
	EpochEnd   uint64 `json:"epoch_end"`
	EpochStart uint64 `json:"epoch_start"`
	Lower      uint64 `json:"lower"`
	Upper      uint64 `json:"upper"`
}

// ValidatorHistory defines model for ValidatorHistory.
type ValidatorHistory struct {
	// Address The staking address of the validator.
	Address *string                 `json:"address,omitempty"`
	History []ValidatorHistoryPoint `json:"history"`

	// IsTotalCountClipped Whether total_count is clipped for performance reasons.
	IsTotalCountClipped bool `json:"is_total_count_clipped"`

	// TotalCount The total number of records that match the query, i.e. the number of records
	// the query would return with limit=infinity.
	TotalCount uint64 `json:"total_count"`
}

// ValidatorHistoryPoint defines model for ValidatorHistoryPoint.
type ValidatorHistoryPoint struct {
	// ActiveBalance The amount of tokens that were delegated to this validator account,
	// at the start of this epoch, and are NOT in the process of debonding.
	ActiveBalance *TextBigInt `json:"active_balance,omitempty"`

	// ActiveShares The shares of tokens that were delegated to this validator account,
	// at the start of this epoch, and are NOT in the process of debonding.
	ActiveShares *TextBigInt `json:"active_shares,omitempty"`

	// DebondingBalance The amount of tokens that were delegated to this validator account
	// at the start of this epoch, but are also in the process of debonding
	// (i.e. they will be unstaked within ~2 weeks).
	DebondingBalance *TextBigInt `json:"debonding_balance,omitempty"`

	// DebondingShares The shares of tokens that were delegated to this validator account
	// at the start of this epoch, but are also in the process of debonding
	// (i.e. they will be unstaked within ~2 weeks).
	DebondingShares *TextBigInt `json:"debonding_shares,omitempty"`

	// Epoch The epoch number.
	Epoch int64 `json:"epoch"`

	// NumDelegators The number of accounts that have delegated token to this account.
	NumDelegators *uint64 `json:"num_delegators,omitempty"`
}

// ValidatorList defines model for ValidatorList.
type ValidatorList struct {
	// IsTotalCountClipped Whether total_count is clipped for performance reasons.
	IsTotalCountClipped bool `json:"is_total_count_clipped"`

	// TotalCount The total number of records that match the query, i.e. the number of records
	// the query would return with limit=infinity.
	TotalCount uint64      `json:"total_count"`
	Validators []Validator `json:"validators"`
}

// ValidatorMedia defines model for ValidatorMedia.
type ValidatorMedia struct {
	// Email An email address associated with the entity.
	Email *string `json:"email,omitempty"`

	// Keybase Keybase handle.
	Keybase *string `json:"keybase,omitempty"`

	// LogoUrl URL to a logo image for the entity.
	LogoUrl *string `json:"logoUrl,omitempty"`

	// Name The human-readable name of this entity.
	Name *string `json:"name,omitempty"`

	// Twitter Twitter handle.
	Twitter *string `json:"twitter,omitempty"`

	// Url An URL associated with the entity.
	Url *string `json:"url,omitempty"`
}

// VerificationLevel The level of verification of a smart contract, as defined by Sourcify.
// An absence of this field means that the contract has not been verified.
// See also https://docs.sourcify.dev/docs/full-vs-partial-match/
type VerificationLevel string

// HumanReadableError defines model for HumanReadableError.
type HumanReadableError struct {
	// Msg An error message.
	Msg string `json:"msg"`
}

// NotFoundError defines model for NotFoundError.
type NotFoundError = interface{}

// GetConsensusAccountsParams defines parameters for GetConsensusAccounts.
type GetConsensusAccountsParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetConsensusAccountsAddressDebondingDelegationsParams defines parameters for GetConsensusAccountsAddressDebondingDelegations.
type GetConsensusAccountsAddressDebondingDelegationsParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetConsensusAccountsAddressDebondingDelegationsToParams defines parameters for GetConsensusAccountsAddressDebondingDelegationsTo.
type GetConsensusAccountsAddressDebondingDelegationsToParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetConsensusAccountsAddressDelegationsParams defines parameters for GetConsensusAccountsAddressDelegations.
type GetConsensusAccountsAddressDelegationsParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetConsensusAccountsAddressDelegationsToParams defines parameters for GetConsensusAccountsAddressDelegationsTo.
type GetConsensusAccountsAddressDelegationsToParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetConsensusBlocksParams defines parameters for GetConsensusBlocks.
type GetConsensusBlocksParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`

	// From A filter on minimum block height, inclusive.
	From *int64 `form:"from,omitempty" json:"from,omitempty"`

	// To A filter on maximum block height, inclusive.
	To *int64 `form:"to,omitempty" json:"to,omitempty"`

	// After A filter on minimum block time, inclusive.
	After *time.Time `form:"after,omitempty" json:"after,omitempty"`

	// Before A filter on maximum block time, exclusive.
	Before *time.Time `form:"before,omitempty" json:"before,omitempty"`

	// Hash A filter on the block hash.
	Hash *string `form:"hash,omitempty" json:"hash,omitempty"`
}

// GetConsensusEntitiesParams defines parameters for GetConsensusEntities.
type GetConsensusEntitiesParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetConsensusEntitiesAddressNodesParams defines parameters for GetConsensusEntitiesAddressNodes.
type GetConsensusEntitiesAddressNodesParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetConsensusEpochsParams defines parameters for GetConsensusEpochs.
type GetConsensusEpochsParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetConsensusEventsParams defines parameters for GetConsensusEvents.
type GetConsensusEventsParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Block A filter on block height.
	Block *int64 `form:"block,omitempty" json:"block,omitempty"`

	// TxIndex A filter on transaction index. The returned events all need to originate
	// from a transaction that appeared in `tx_index`-th position in the block.
	// It is invalid to specify this filter without also specifying a `block`.
	// Specifying `tx_index` and `block` is an alternative to specifying `tx_hash`;
	// either works to fetch events from a specific transaction.
	TxIndex *int32 `form:"tx_index,omitempty" json:"tx_index,omitempty"`

	// TxHash A filter on the hash of the transaction that originated the events.
	// Specifying `tx_index` and `block` is an alternative to specifying `tx_hash`;
	// either works to fetch events from a specific transaction.
	TxHash *string `form:"tx_hash,omitempty" json:"tx_hash,omitempty"`

	// Rel A filter on related accounts. Every returned event will refer to
	// this account. For example, for a `Transfer` event, this will be the
	// the sender or the recipient of tokens.
	Rel *StakingAddress `form:"rel,omitempty" json:"rel,omitempty"`

	// Type A filter on the event type.
	Type *ConsensusEventType `form:"type,omitempty" json:"type,omitempty"`
}

// GetConsensusProposalsParams defines parameters for GetConsensusProposals.
type GetConsensusProposalsParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Submitter Filter on the submitter of the proposal.
	Submitter *StakingAddress `form:"submitter,omitempty" json:"submitter,omitempty"`

	// State Filter on the state of the proposal.
	State *ProposalState `form:"state,omitempty" json:"state,omitempty"`
}

// GetConsensusProposalsProposalIdVotesParams defines parameters for GetConsensusProposalsProposalIdVotes.
type GetConsensusProposalsProposalIdVotesParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetConsensusRoothashMessagesParams defines parameters for GetConsensusRoothashMessages.
type GetConsensusRoothashMessagesParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset  *uint64              `form:"offset,omitempty" json:"offset,omitempty"`
	Runtime Runtime              `form:"runtime" json:"runtime"`
	Round   *int64               `form:"round,omitempty" json:"round,omitempty"`
	Type    *RoothashMessageType `form:"type,omitempty" json:"type,omitempty"`
	Rel     *StakingAddress      `form:"rel,omitempty" json:"rel,omitempty"`
}

// GetConsensusTransactionsParams defines parameters for GetConsensusTransactions.
type GetConsensusTransactionsParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Block A filter on block height.
	Block *int64 `form:"block,omitempty" json:"block,omitempty"`

	// Method A filter on transaction method.
	Method *ConsensusTxMethod `form:"method,omitempty" json:"method,omitempty"`

	// Sender A filter on transaction sender.
	Sender *StakingAddress `form:"sender,omitempty" json:"sender,omitempty"`

	// Rel A filter on related accounts.
	Rel *string `form:"rel,omitempty" json:"rel,omitempty"`

	// After A filter on minimum transaction time, inclusive.
	After *time.Time `form:"after,omitempty" json:"after,omitempty"`

	// Before A filter on maximum transaction time, exclusive.
	Before *time.Time `form:"before,omitempty" json:"before,omitempty"`
}

// GetConsensusValidatorsParams defines parameters for GetConsensusValidators.
type GetConsensusValidatorsParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Name A filter on the validator name. Every returned validator will have
	// a name that is a superstring of the input param.
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// GetConsensusValidatorsAddressHistoryParams defines parameters for GetConsensusValidatorsAddressHistory.
type GetConsensusValidatorsAddressHistoryParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`

	// From A filter on minimum epoch number, inclusive.
	From *int64 `form:"from,omitempty" json:"from,omitempty"`

	// To A filter on maximum epoch number, inclusive.
	To *int64 `form:"to,omitempty" json:"to,omitempty"`
}

// GetLayerStatsActiveAccountsParams defines parameters for GetLayerStatsActiveAccounts.
type GetLayerStatsActiveAccountsParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`

	// WindowStepSeconds The size of the step between returned statistic windows, in seconds.
	// The backend supports a limited number of step sizes: 300 (5 minutes) and
	// 86400 (1 day). Requests with other values may be rejected.
	WindowStepSeconds *uint32 `form:"window_step_seconds,omitempty" json:"window_step_seconds,omitempty"`
}

// GetLayerStatsTxVolumeParams defines parameters for GetLayerStatsTxVolume.
type GetLayerStatsTxVolumeParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`

	// WindowSizeSeconds The size of windows into which the statistic is grouped, in seconds.
	// The backend supports a limited number of window sizes: 300 (5 minutes) and
	// 86400 (1 day). Requests with other values may be rejected.
	WindowSizeSeconds *uint32 `form:"window_size_seconds,omitempty" json:"window_size_seconds,omitempty"`

	// WindowStepSeconds The size of the step between returned statistic windows, in seconds.
	// The backend supports a limited number of step sizes: 300 (5 minutes) and
	// 86400 (1 day). Requests with other values may be rejected.
	WindowStepSeconds *uint32 `form:"window_step_seconds,omitempty" json:"window_step_seconds,omitempty"`
}

// GetRuntimeAccountsAddressNftsParams defines parameters for GetRuntimeAccountsAddressNfts.
type GetRuntimeAccountsAddressNftsParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`

	// TokenAddress Only return NFT instances from the token contract at the given staking address.
	TokenAddress *EthOrOasisAddress `form:"token_address,omitempty" json:"token_address,omitempty"`
}

// GetRuntimeBlocksParams defines parameters for GetRuntimeBlocks.
type GetRuntimeBlocksParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`

	// From A filter on minimum block height, inclusive.
	From *int64 `form:"from,omitempty" json:"from,omitempty"`

	// To A filter on maximum block height, inclusive.
	To *int64 `form:"to,omitempty" json:"to,omitempty"`

	// After A filter on minimum block time, inclusive.
	After *time.Time `form:"after,omitempty" json:"after,omitempty"`

	// Before A filter on maximum block time, exclusive.
	Before *time.Time `form:"before,omitempty" json:"before,omitempty"`

	// Hash A filter on the block hash.
	Hash *string `form:"hash,omitempty" json:"hash,omitempty"`
}

// GetRuntimeEventsParams defines parameters for GetRuntimeEvents.
type GetRuntimeEventsParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Block A filter on block round.
	Block *int64 `form:"block,omitempty" json:"block,omitempty"`

	// TxIndex A filter on transaction index. The returned events all need to originate
	// from a transaction that appeared in `tx_index`-th position in the block.
	// It is invalid to specify this filter without also specifying a `block`.
	// Specifying `tx_index` and `round` is an alternative to specifying `tx_hash`;
	// either works to fetch events from a specific transaction.
	TxIndex *int32 `form:"tx_index,omitempty" json:"tx_index,omitempty"`

	// TxHash A filter on the hash of the transaction that originated the events.
	// Specifying `tx_index` and `round` is an alternative to specifying `tx_hash`;
	// either works to fetch events from a specific transaction.
	// This can be an Ethereum transaction hash; the query will compare against
	// both a transaction's regular tx_hash and eth_tx_hash (if it exists).
	TxHash *string `form:"tx_hash,omitempty" json:"tx_hash,omitempty"`

	// Type A filter on the event type.
	Type *RuntimeEventType `form:"type,omitempty" json:"type,omitempty"`

	// Rel A filter on related accounts. Every returned event will refer to
	// this account. For example, for a `accounts.Transfer` event, this will be
	// the sender or the recipient of tokens.
	Rel *EthOrOasisAddress `form:"rel,omitempty" json:"rel,omitempty"`

	// EvmLogSignature A filter on the evm log signatures.
	// Note: The filter will only match on parsed (verified) EVM events.
	EvmLogSignature *string `form:"evm_log_signature,omitempty" json:"evm_log_signature,omitempty"`

	// ContractAddress A filter on a smart contract. Every returned event will have been
	// emitted by the contract at this address.
	ContractAddress *EthOrOasisAddress `form:"contract_address,omitempty" json:"contract_address,omitempty"`

	// NftId A filter on NFT events. Every returned event will be specifically
	// about this NFT instance ID. You must specify the contract_address
	// filter with this filter.
	// Currently this only supports ERC-721 Transfer events.
	// This may expand to support other event types in the future.
	// If you want only ERC-721 Transfer events, specify
	// evm_log_signature=ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
	// to avoid inadvertently getting other event types if they are
	// supported later.
	// Using an evm_log_signature filter with this set to any other value
	// will match no events.
	NftId *string `form:"nft_id,omitempty" json:"nft_id,omitempty"`
}

// GetRuntimeEvmTokensParams defines parameters for GetRuntimeEvmTokens.
type GetRuntimeEvmTokensParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Name A filter on the name, the name or symbol must contain this value as a substring.
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// GetRuntimeEvmTokensAddressHoldersParams defines parameters for GetRuntimeEvmTokensAddressHolders.
type GetRuntimeEvmTokensAddressHoldersParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetRuntimeEvmTokensAddressNftsParams defines parameters for GetRuntimeEvmTokensAddressNfts.
type GetRuntimeEvmTokensAddressNftsParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetRuntimeTransactionsParams defines parameters for GetRuntimeTransactions.
type GetRuntimeTransactionsParams struct {
	// Limit The maximum numbers of items to return.
	Limit *uint64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of items to skip before starting to collect the result set.
	Offset *uint64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Block A filter on block round.
	Block *int64 `form:"block,omitempty" json:"block,omitempty"`

	// After A filter on minimum transaction time, inclusive.
	After *time.Time `form:"after,omitempty" json:"after,omitempty"`

	// Before A filter on maximum transaction time, exclusive.
	Before *time.Time `form:"before,omitempty" json:"before,omitempty"`

	// Rel A filter on related accounts. Every returned transaction will refer to
	// this account in a way. For example, for an `accounts.Transfer` tx, this will be
	// the sender or the recipient of tokens.
	// Nexus detects related accounts inside EVM transactions and events on a
	// best-effort basis. For example, it inspects ERC20 methods inside `evm.Call` txs.
	Rel *EthOrOasisAddress `form:"rel,omitempty" json:"rel,omitempty"`
}
